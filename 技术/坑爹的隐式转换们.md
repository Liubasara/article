---
name: 坑爹的隐式转换们
title: 坑爹的隐式转换们
tags: ["技术"]
categories: 学习笔记
info: "无忌你要记住，越是漂亮的等式，就越会骗人"
time: 2020/8/4
desc: '学习笔记, 前端面试, javascript, 隐式转换'
keywords: ['前端面试', '学习笔记', 'javascript', '隐式转换']
---

# 坑爹的隐式转换们

> 参考资料：
>
> - [[] == ![] !? 浅析JS的类型系统和隐式类型转换](https://juejin.im/post/6844903983429976078#heading-2)

JS 中的隐式转换准则

- 规则一：对于不同基本类型的比较，始终会把所有的类型最终转换为字符串或是数字来进行处理或判断，而这种判断又有两种不同的倾向，分别为：倾向于转为字符串的`+`转换（加号的任意一边有字符串，则对另一边调用`String`方法，若没有字符串，则调用`Number`方法），以及倾向于转换为数字的`==`转换（对两边调用`Number`方法）。

  比如：
  
  - `false + '1'`的结果就是将布尔值`false`调用 String 方法转换为字符串`'false'`，导致最后的结果为字符串`'false1'`
  - 而`false + 1`由于加号两边没有字符串，所以对`false`调用 Number 方法，最终结果是`0 + 1`得出结果为 1
  - 而`true == '1'`的内在逻辑则是通过 Number 方法将布尔值`true`转换为数字`1`，将字符串`'1'`也转换为数字`1`，再进行`1 == 1`的对比，最终返回`true`。

- 规则二：对象与非对象类型（即除了 Symbol 以外的基本类型）进行对比或相加的时候，会调用 JS 的一个内部方法`ToPrimitive`，该方法会先调用对象的 valueOf 方法，如果调用返回的是基本类型，就正常使用，如果还是引用类型，就会调用对象的 toString 方法。

  比如：`({}).valueOf`的结果还是`{}`，所以`{}`在相加和相等操作时会调用`({}).toString`方法得到`"[object Object]"`，但是如果你覆盖了这个对象内部的 valueOf 方法，相当于就可以自由的操纵其隐式转换返回的结果了。

  ```javascript
  var obj = {
      valueOf: function () {
          return '123'
      }
  }
  obj == '123' // true
  obj == 123 // 相当于 '123' == 123 根据规则一，== 转换时倾向于将两边转换成数字，所以转换为 123 == 123，所以返回 true
  ```

- 规则三：在隐式转化中，对于`+!`等转化符号的处理要优先于`==`号。

  比如臭名昭著的`[] == ![]`这起密室等于事件，就是因为`!`犯人先将`[]`转化成了布尔值`true`再取反变成了`false`，于是变成了`[] == false`。然后又触发了受害者`[]`的 ToPrimitive 方法，依次调用 valueOf 方法（还是返回`[]`，pass）和 toString 方法以后返回了`''`，于是案件变成了`'' == false`，最后再根据规则一：== 转换倾向于转换成数字对比，将`''`和`false`经过转换都成了数字 0，于是`0 == 0`，结果成立，返回`true`。



**结论**：少点转换，珍爱生命，世界和平。