---
name: 简单理解浏览器中的进程和线程
title: 简单理解浏览器中的进程和线程
tags: ["技术"]
categories: 学习笔记
info: "厨子与锅铲的区别"
time: 2020/7/28
desc: '学习笔记, 前端面试, 进程线程'
keywords: ['前端面试', '学习笔记', '进程线程', '浏览器']
---

# 简单理解浏览器中的进程和线程

> 引用资料：
>
> - [js的单线程和多进程详细讲解](http://www.lucklnk.com/godaddy/details/aid/509517905)
> - [Linux系统中 进程 、线程 、时间片的关系？](https://www.zhihu.com/question/64723752)

以下仅为 CS 小白的个人理解。

## 进程和线程的区别

进程是 CPU 资源占用的最小单位，每个进程占用的资源是相互独立的，想要互相通信就只能通过 CPU 切换上下文环境或者彼此之间发送信号，也就是说彼此的变量都是独立的。

而线程是 CPU 在进行调度时的最小单位，一个进程可以拥有多个线程，多线程模式下 CPU 可以通过分配时间片的方式更加效率的得到利用（通俗来说就是 CPU 可以先干干这个，然后停下来干干那个），而这些线程彼此之间的资源是互通的，执行也是同时进行的（Linux里的线程实际上是共享一些资源的一系列进程而已。），因此像 JAVA、C++ 这样的多线程语言就需要引入锁机制来避免资源调动之间的抢夺。也正因多线程共用一片资源，所以其切换开销要比多进程要小的多。

## 浏览器中有哪些线程？

以 chrome 浏览器为例，每个标签页其实都是一个独立的进程，标签页彼此之间虽然也有通信的途径（比如说某些扩展可以合并标签页）但开销较大。而每个标签页所代表的独立进程中又有多个线程，所谓**javascript 是单线程执行**的这个说法，指的其实也是浏览器中的 JS 引擎线程。其主要的几个线程有：

- **GUI 渲染线程**，负责解析 DOM、CSS、构建 Render Tree 布局和绘制等。注意该线程和 javascript 的引擎线程是互斥的，javascript 执行时，为了避免重复渲染和元素大小出错，渲染引擎会暂时挂起。
- **JS 引擎线程(V8)**，也称为 JS 内核，负责处理 javascript，并不停的从事件队列中出列任务进行执行。
- **事件触发线程**，用于控制事件循环，当事件被触发时，将这些任务的回调函数添加到事件线程中，等待 JS 引擎的处理。
- **定时触发线程**，专门用于处理 setTimeout/setInterval 等定时器的倒计时，等时间到了就会将他们置入事件循环队列当中去，待 JS 引擎执行。
- **异步 http 请求线程**，网络模块线程，在 XMLHttpRequest 连接后通过浏览器新开一个线程请求，如果有回调，就将这个回调交由事件触发线程放入事件队列中，等待 JS 引擎线程的执行。

## 由此引申出对 node（单线程后台服务器） 和 apache（多线程后台服务器）的一些思考

javascript 即便执行在 node 中也是单线程语言，所有请求都会通过 IO 等观察者线程放入消息队列中，通过 libv 这样的底层不停的循环出列来执行。而像 apache 为代表的 JAVA 系多线程后台服务器则是通过维护一个**线程池**，每次有连接进来都会从线程池中拿走一个空余的线程进行处理，处理完毕后再释放当前线程。

由此不难看出两者的区别，像 node 这样的服务模式，其性能的核心瓶颈在于单线程的处理能力和单线程对于 CPU 的使用不够彻底，这也是其被称为不擅长执行**计算密集型**任务的原因，试想同样执行一个 1+2+...+n 的计算，node 只能一个单线程傻呆呆的一个数一个数累加，而这中间 node 所有的需要 JavaScript 处理的其他任务（比如事件调度，响应等等）都得等待该任务的完成，而多线程语言则可以通过调度起多个任务，将 CPU 的执行通过时间分片来执行其他任务，使得单一任务的执行并不影响其他任务的进行。

但线程池模式的性能瓶颈也很容易能看出，线程池中线程的数量总归是有限的，一旦并发数量达到一个量级，请求就会因为无法进入分配到线程池而宣告阻塞或者干脆被拒绝访问。试想如果有一个请求是计算 1+2+3+4 结果的任务，但是这样的任务同时有十万个而线程池不足，必然会导致多线程的处理模式触发异常，由此可看出**为一些简单的任务分配一个单独线程，最后还要归还释放，本身就是一个高门槛且浪费性能的一件事**。所以对于**IO密集型**任务来说，node 那样的通过消息队列单线程执行任务的方式更优。