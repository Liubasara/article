---
name: 红宝书学习笔记（五）
title: 红宝书（javascirpt高级程序设计）学习笔记（五）
tags: ['读书笔记', '红宝书', 'javascript高级程序设计']
categories: 学习笔记
info: "人类的好伙伴，红宝书（五）"
time: 2019/1/27,
desc: 'javascirpt高级程序设计, 红宝书, 资料下载, 学习笔记, 第7章'
keywords: ['前端', '红宝书笔记', '学习笔记', '第7章 函数表达式']
---

# 红宝书（javascirpt高级程序设计）学习笔记（五）

## 第7章 函数表达式

**本章介绍函数表达式、闭包、活动对象等概念是在面向对象开发时不可或缺的，本章适合仔细阅读，做好笔记。**

在ECMAScript中，有两种方式定义函数，一种被称为**函数声明提升**，另一种则是**函数表达式**。

```javascript
// 函数声明提升
function functionName(arg0, arg1, arg2) {
    
}
// 函数表达式
var functionName = function (arg0, arg1, arg2) {
    
}
```

函数声明提升有一个重要的特征，即会在执行代码之前先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。但是**函数表达式就不可以**。

而与此同时这也就意味着，使用函数声明提升来创建的函数是不会依照程序逻辑来进行生成的，但函数表达式就可以。

```javascript
// 错误做法
if (condition) {
    function a () {console.log('a')}
} else {
    function a () {console.log('b')}
}

// 正确做法
var a
if (condition) {
    a = function () {console.log('a')}
} else {
    a = function () {console.log('b')}
}
```

### 7.1 递归

递归函数的一个重要思想就是一个函数要通过名字不停的调用自身，如下所示

```javascript
// 递归阶乘函数
function factorial (num) {
    if (num <= 1) {
        return 1
    } else {
        return num * factorial(num - 1)
    }
}
```

这是一个经典的递归阶乘函数，但是这个函数依赖于factorial这个变量，当我们将factorial这个变量赋予另外一个值时，程序就会报错，而在这种情况下，可以使用arguments.callee解决这个问题。

```javascript
// 递归阶乘函数(使用arguments.callee)
function factorial (num) {
    if (num <= 1) {
        return 1
    } else {
        return num * arguments.callee(num - 1)
    }
}
```

arguments.callee是一个指向函数本身的指针，可以用于实现对函数的递归调用。可是在严格模式下，不能访问这个属性，所以我们可以通过另外一种方式解决。

```javascript
// 递归阶乘函数
var factorial = function f (num) {
    if (num <= 1) {
        return 1
    } else {
        return num * f(num - 1)
    }
}
```

以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数值赋给了另一个变量，函数的名字f依然有效，所以递归调用一样能正确完成。

### 7.2 闭包

闭包，用一句话来解释其实就是有权访问另一个函数作用域中的变量的函数。

当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的**活动对象**。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位……直至作为作用域链终点的全局执行环境

#### 7.2.1 闭包与变量

作用域链这种配置机制引出了一个值得注意的**副作用**，即闭包只能取得包含函数中任何变量的**最后一个值**，而不是某个特殊的变量。

```javascript
function test () {
    var result = new Array()
    for (var i = 0; i < 10; i++) {
        retult[i] = function () {
            return i
        }
    }
    return result
}
test // [10, 10, 10,...] 返回10个元素值为10的数组
```

上面这个示例函数之所以没有达到我们预期中的效果，主要是因为三点：

- ESMAScript5 中没有块级作用域
- var 定义参数会有变量提升的效果（即定义的是一个全局变量）
- 作用域链导致只能函数只能引用到最后的一个变量i

要解决这个问题有两种方法，最简单的一种是使用ES6新定义的语法let，而另一种则是在循环中，放弃从作用域链中引参数，转而给result[i]赋予一个**立即执行**的匿名函数。

```javascript
// ES6 解决方法
function test () {
    var result = new Array()
    for (let i = 0; i < 10; i++) {
        retult[i] = function () {
            return i
        }
    }
    return result
}
/** 
上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
**/

// 立即执行的匿名函数
function test () {
    var result = new Array()
    for (let i = 0; i < 10; i++) {
        result[i] = (function (i) {
            return i
           })(i)
    }
    return result
}
```

#### 7.2.2 关于this对象（箭头函数）

this 对象实在运行时基于函数的执行环境绑定的（虽然也可以通过this，apply等方法动态绑定）。在全局函数中，this等于windows，而当函数被某个对象的方法调用时，this等于那个对象。不过，**匿名函数的执行环境具有全局性，因此其this对象通常指向windows**。

简单来说，就是哪个对象调用了这个函数，函数就会认定哪个对象是它的活动对象，this也就绑定谁。而匿名函数的环境之所以具有全局性，基本上也就是因为没有办法通过一个指定的对象来调用这个函数。（在对象内没有名字，想调用也调用不了啊。）

> 而ES6中的箭头函数与ES5中的普通函数有所不同的是，它的this对象是在声明函时绑定的，也就是说其this对象并不依赖于执行环境，而是依赖于生成时所在的对象。
>
> 具体例子可看[这里](http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0)

### 7.3 模仿块级作用域

JavaScript中没有块级作用域的概念，但实际上，我们可以通过使用一个**立即执行的匿名函数**来模仿块级作用域。

```javascript
(function () {
    // 这里是块级作用域
})()
```

立即执行的匿名函数会在执行完后自动销毁其作用域链，这样就可以达到声明变量而不污染全局变量的效果了。



本次阅读至P185  7.4 私有变量