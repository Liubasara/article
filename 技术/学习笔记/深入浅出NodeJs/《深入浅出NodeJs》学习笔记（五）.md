---
name: 《深入浅出NodeJs》学习笔记（五）
title: 《深入浅出NodeJs》学习笔记（五）
tags: ['读书笔记', '深入浅出NodeJs']
categories: 学习笔记
info: "深入浅出NodeJs 第5章 内存控制"
time: 2019/5/28
desc: '深入浅出NodeJs, 资料下载, 学习笔记, 第5章 内存控制'
keywords: ['深入浅出NodeJs资料下载', '前端', '深入浅出NodeJs', '学习笔记', '第5章 内存控制']
---

# 《深入浅出NodeJs》学习笔记（五）

## 第5章 内存控制

> 在过去很长一段时间内，JavaScript 开发者很少在开发过程中遇到需要对内存精确控制的场景，也缺乏控制的手段。基于无阻塞、事件驱动建立的Node服务，具有内存消耗低的优点，非常适合处理海量的网络请求。在海量请求的前提下，开发者就需要考虑一些平常不会形成影响的问题。
>
> 内存控制正是在海量请求和长时间运行的前提下进行探讨的。在服务器端，资源向来就寸土寸金，要为海量用户服务，就得使一切资源都要高效循环利用。 在第3章中，差不多已介绍完Node是如何利用CPU和I/O这两个服务器资源，而本章将介绍在Node 中如何合理高效地使用内存

### 5.1 V8 的垃圾回收机制与内存限制

JavaScript 有一套自己的垃圾回收机制用于自动内存管理，让开发者可以在编写代码的过程中无需时刻关注内存的分配和释放问题。所以在前端开发中，很少有人能遇到垃圾回收对应用程序构成性能影响的情况。

而Node 拓宽了 JavaScript 的应用场景，内存管理对其的影响也变得重要了起来，而这一切的关键点，都与 Node 的 JavaScript 执行引擎 V8 息息相关。

#### 5.1.1 Node 与 V8

> Node在JavaScript的执行上直接受益于V8，可以随着V8的升级就能享受到更好的性能或新的 语言特性（如ES5和ES6）等，同时也受到V8的一些限制，尤其是本章要重点讨论的内存限制。 

#### 5.1.2 V8 的内存限制

在一般的后端开发语言中，在内存的使用上一般没有什么限制，然而在 Node 中通过 JavaScript 使用内存则会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB）。在这样的限制下，决定了 Node 无法直接操作大内存对象，计算机内存资源也无法得到充足的使用。

> V8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。
>
> 深层原因是V8的垃圾回收机制的限制。 按官方的说法，以1.5 GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一 次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受， 前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。 
>
> 虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。
> 在启动node程序的时候，可以传递两个参数来调整内存限制的大小。
>
> ```shell
> node --max-nex-space-size=1024 app.js // 单位为KB
> node --max-old-space-size=2000 app.js // 单位为MB
> ```
>
> 上述参数在V8初始化时生效，一旦生效就不能再动态改变。如果遇到Node无法分配足够内 存给JavaScript对象的情况，可以用这个办法来放宽V8默认的内存限制，避免在执行过程中稍微 多用了一些内存就轻易崩溃。
>
> 这两条命令分别对应Node内存堆中的「新生代」和「老生代」
>
> **不受内存限制的特例**
>
> 在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求

#### 5.1.3 V8 的对象分配

在 V8 中，所有的 JavaScript 对象都是通过*堆*来进行分配的。当我们在代码中声明变量并赋值时，所使用的内存就分配在堆中。如果已申请的内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制为止。

#### 5.1.4 V8 的垃圾回收机制

V8主要使用以下几种垃圾回收算法：

1. 分代式垃圾回收机制

   > 在自动垃圾回收的演变过程中，人们发 现没有一种垃圾回收算法能够胜任所有的场景。因为在实际的应用中，对象的生存周期长短不一。为此，统计学在垃圾回收算法的发展中产生了较 大的作用，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。

   

   **分代**

   在 V8 中，主要讲内存分为**新生代**和**老生代**两代。**新生代**中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

   ![V8memory.jpg](./images/V8memory.jpg)

   V8 堆的整体大小就是新生代所用的内存空间加上老生代的内存空间。

   在默认设置下，老生代的设置在64位系统下为 1400MB （总空间为1.4G），在32位系统下为 700MB（总空间700MB）

   新生代由两个`reserved_semispace_size`组成，其的设置在64位系统下为 16MB，32位系统下为 8MB。所以新生代在64位和32位下的最大值分别文32MB和16MB。

   而V8堆内存的最大保留空间的公式也由此得来：`4 * reserved_semispace_ size_ + max_old_generation_size_`

   在分代的基础上，新生代中的对象又可以通过 Scavenge 算法进行垃圾回收。

   **Scavenge 算法**

   > 它将堆内存一分为二，每一部分空 间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处 于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象 时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这 些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空 间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个 semispace空间之间进行复制。
   >
   > Scavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但 Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。
   >
   > ![newGenerationMemory.jpg](./images/newGenerationMemory.jpg)

   

2. Mark-Sweep & Mark-Compact 

   对于老生代中的对象采用 Scavenge 算法的效率会很低，并且会浪费一半的空间。为此，Node 选用了标记清除的方式来进行空间回收，也就是我们所熟悉的浏览器主流算法。

   > Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep 并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同， Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除 没有被标记的对象。可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。 活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处 理的原因。图5-6为Mark-Sweep在老生代空间中标记后的示意图，黑色部分标记为死亡的对象。
   >
   > ![markMemory.jpg](./images/markMemory.jpg)
   >
   > Mark-Sweep大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种 内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有 的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 
   >
   > 为了解决Mark-Sweep的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记整理 的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的 过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

   V8 主要使用 Mark-Sweep，在空间不足对从新生代晋升过来的对象进行分配时才使用 Mark-Compact。

3. Incremental Marking

   上面介绍的两种方法都可以被分类为“全停顿法”，在垃圾回收时都需要将应用逻辑暂停下来，以防止出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况。

   为了降低全堆垃圾回收带来的停顿时间，V8 采用了增量标记的标记方法，每次标记完后都让 JavaScript 应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。从而降低其最大停顿时间。

   > V8后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清 理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低 每次停顿的时间。

#### 5.1.5 查看垃圾回收日志





> 本次阅读至P119 5.1.5 查看垃圾回收日志 137