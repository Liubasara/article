---
name: 《C#高级编程》学习笔记（12）
title: 《C#高级编程》学习笔记（12）
tags: ["技术","学习笔记","C#高级编程"]
categories: 学习笔记
info: "C#高级编程 第14章 错误和异常 第 15 章 异步编程"
time: 2023/8/6
desc: 'C#高级编程, 学习笔记, 第14章 错误和异常, 第 15 章 异步编程'
keywords: ['学习笔记', 'C#', 'C#高级编程', '第14章 错误和异常', '第 15 章 异步编程']

---

#  《C#高级编程》学习笔记（12）

## 第14章 错误和异常

### 14.1 简介

本章介绍：

- 在多种不同的场景中捕获和抛出异常的方式
- 讨论不同 namespace 中定义的异常类型及其层次结构
- 学习如何创建自定义异常类型
- 捕获异常的不同方式
- try/finally 块

### 14.2 异常类

C# 提供了许多预定义的异常类，以下是其中一些常见的类：

![14-1.png](./images/14-1.png)

### 14.3 捕获异常

为了在 C# 代码中处理可能的错误情况，一般要把程序的相关部分分成 3 种不同类型的代码块：

- try 块
- catch 块
- finally 块

![14-2.png](./images/14-2.png)

> 值得注意的是，传递给 catch 块的参数只能用于该 catch 块，这就是为什么在上面的代码中，所有后续 catch 块都使用相同的参数名 ex。

在 System.Exception 异常类中，除了 Message 属性以外，还有许多其他属性。

![14-3.png](./images/14-3.png)

从 C#6 之后，catch 块支持了异常过滤器，用于过滤筛选一些具有特定属性的异常。比如：

![14-4.png](./images/14-4.png)

#### 14.3.6 重新抛出异常

捕获异常后重新再抛出异常也是非常普遍的，再次抛出异常时，可以改变异常的类型，或者给调用程序提供异常相关的更多信息。

重新抛出异常的问题是，调用程序往往需要通过以前的异常找出其发生的原因和地点，堆栈跟踪信息可能会丢失。

![14-5.png](./images/14-5.png)

![14-6.png](./images/14-6.png)

### 14.4 用户定义的异常类

> ChatGPT：
>
> 在C#中，可以通过继承`Exception`类来创建自定义异常类，并定义该异常类的行为。下面是一个具体的例子：
>
> ```csharp
> using System;
> 
> // 自定义异常类
> public class MyCustomException : Exception
> {
>     // 自定义异常类的构造函数
>     public MyCustomException(string message) : base(message)
>     {
>         // 在构造函数中可以执行一些自定义的逻辑
>         // 例如记录日志、发送通知等
>     }
>     
>     // 可以在自定义异常类中定义其他的属性和方法
>     // 根据需要来扩展异常类的行为
> }
> 
> public class Program
> {
>     public static void Main()
>     {
>         try
>         {
>             // 抛出自定义异常
>             throw new MyCustomException("发生了自定义异常");
>         }
>         catch (MyCustomException ex)
>         {
>             // 捕获并处理自定义异常
>             Console.WriteLine("捕获到自定义异常：" + ex.Message);
>         }
>         catch (Exception ex)
>         {
>             // 捕获其他异常
>             Console.WriteLine("捕获到异常：" + ex.Message);
>         }
>     }
> }
> ```
>
> 在上面的例子中，我们首先定义了一个名为`MyCustomException`的自定义异常类，该类继承自`Exception`类。在自定义异常类中，我们可以添加自己的构造函数、属性和方法，以满足特定的需求。
>
> 在`Main`方法中，我们使用`throw`关键字抛出了一个`MyCustomException`的实例，并在`catch`块中捕获并处理该异常。注意，异常的`catch`块是按照顺序匹配的，所以在捕获自定义异常之前，如果存在其他更一般的异常类型，也会被匹配并处理。
>
> 通过自定义异常类，我们可以根据具体的业务需求来定义异常的行为，例如记录日志、发送通知等。这样可以提高代码的可读性和可维护性，同时也能更好地处理异常情况。

### 14.5 调用者信息

为了在报错中从堆栈中获得行号、文件名和成员名，我们可以在编写代码时使用 C# 编译器支持的特性和可选参数。

![14-7.png](./images/14-7.png)

![14-8.png](./images/14-8.png)

## 第 15 章 异步编程













> 本次阅读至 P346  第 15 章 异步编程 下次阅读应至 P361 有用的一共也就17章

