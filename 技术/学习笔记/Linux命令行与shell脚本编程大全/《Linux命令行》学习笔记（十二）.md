---
name: 《Linux命令行》学习笔记（十二）
title: 《Linux命令行》学习笔记（十二）
tags: ["技术","学习笔记","Linux命令行与shell脚本编程大全"]
categories: 学习笔记
info: "第14章 处理用户输入"
time: 2020/6/3
desc: 'Linux命令行与shell脚本编程大全, 资料下载, 学习笔记, 第14章 处理用户输入'
keywords: ['Linux命令行与shell脚本编程大全', 'shell学习', '学习笔记', '第14章 处理用户输入']
---

# 《Linux命令行》学习笔记（十二）

## 第14章 处理用户输入

本章将会讨论如何在你的bash shell脚本运用这些方法来从脚本用户处获得数据。

>  本章内容：
>
> - 传递参数
> - 跟踪参数
> - 移动变量
> - 处理选项
> - 将选项标准化
> - 获得用户输入

### 14.1 命令行参数

向 shell 脚本传递数据的最基本方法是使用命令行参数，如`./myshell.sh 10 30`这样。

#### 14.1.1 读取参数

bash shell 会将一些称为`位置参数`的特殊变量分配给输入到命令行中的参数。

未知参数变量是标准的数字：`$0`是程序名，`$1`是第一个参数，`$2`是第二个，以此类推到第九个`$9`。

```shell
#!/bin/bash
# 阶乘
factorial=1
for (( number = 1; number <= $1; number++ ))
do
	factorial=$[ $factorial * $number ]
done
echo "阶乘的值为$factorial"
```

如果需要输入更多的命令行参数，则每个参数之间需要用空格分开。而如果要在参数值中包含空格，必须要用引号（单引号双引号都可）。

而如果脚本需要的参数不止九个，你就需要稍微修改一下变量名，从第 10 个变量之后，就必须在变量数字周围加上花括号，如`${10}`这样来使用。

#### 14.1.2 读取脚本名

使用`$0`可以获取 shell 在命令行启动时的脚本名。

```shell
#!/bin/bash
echo "zero parameter is: $0"
```

这样当你使用`sh test.sh`来执行的话，就会输出`zero parameter is: test.sh`。

但上面的实际变量并不仅仅是脚本名，而是完整的脚本路径，如果在执行脚本时使用了相对路径或绝对路径，就会连路径本身也一起输出来。如执行`bash /home/xxx/test.sh`得到的输出就会是`zero parameter is: /home/xxx/test.sh`。

果你要编写一个根据脚本名来执行不同功能的脚本，就得做点额外工作。你得把脚本的运行路径给剥离掉，使用`basename`命令可以帮助我们返回不包含路径的脚本名。

```shell
#!bin/bash
name=$(bashname $0)
echo "script name is $name"
```

这样就可以根据脚本的名字来让控制代码的流程代码了。

#### 14.1.3 测试参数

> 当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。这种写 脚本的方法并不可取。在使用参数前一定要检查其中是否存在数据。    

```shell
#!/bin/bash
# 使用字符串命令检测中的 -n 选项，可以检测输入字符串是否为非0
if [ -n "$1" ]
then
	echo Hello $1
else
	echo "不存在"
fi
```

### 14.2 特殊参数变量

#### 14.2.1 参数统计

> 你可以统计一下命令行中输入了多少个参数，无需测试每个参数。 bash shell为此提供了一个 特殊变量。 
>
> 特殊变量`$#`含有脚本运行时携带的命令行参数的个数数量。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。

```shell
#!/bin/bash
if [ $# -ne 2 ]
then
	# 参数数量不为 2
	echo "参数数量不为 2"
else
	echo "参数1：$1 参数2：$2"
fi
```

此外，你还可以使用`${!#}`来代表最后一个命令行参数变量。

#### 14.2.2 抓取并遍历所有数据

接下来还是两个特殊变量：`$*`和`$@`。

这两个变量都代表着所有的输入数据，不同的是`$*`会将所有输入的词当成一个单词，而`$@`则会默认进行空格分词。这也就意味着如果想用`for`循环来遍历输入，只能使用会分词的`$@`变量，下面是例子。

```shell
#!/bin/bash
for param in "$*"
do
	echo "$param"
done

for params in "$@"
do
	echo "$params"
done
```

执行上面的代码。

```shell
./test.sh ddd lsls wiwiw

# ddd lsls wiwiw
# ddd
# lsls
# wiwiw
```

### 14.3 移动变量

使用`shift`命令会默认将每个参数变量向左移动一个位置，使用后，$2 变量的值会移动到 $1 中。

这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作 第一个参数，移动参数，然后继续操作第一个参数。

```shell
#!/bin/bash
while [ -n "$1" ]
do
	echo "参数为： $1"
	shift
done
```

> 使用shift命令的时候要小心。如果某个参数被移出，它的值就被丢弃了，无法再恢复。

此外也可以通过给`shift n`的方式给一个参数来指明要移动的位数。

### 14.4 处理选项

利用上面所学知识，配合使用就可以写出一套能检测到参数并做出正确处理的代码。

`./testing.sh -a test1 -b -c -d test2    `

```shell
#!/bin/bash
while [ -n "$1" ]
do
	case "$1" in
		-a) echo "识别 -a 参数并获取后面的值"
		-b) param="$2"
			  echo "检测到 -b 选项"
			  shift
		-c) echo "检测到 -c 选项"
		--) echo "检测到 -- 选项，该项之后的参数不会被识别为功能选项而会识别为值"
			  shift
			  break
		*)  echo "$1 不是一个选项"
	esac
	shift
done

for param in "$@"
do
	echo "选项值为：$param"
done
```

用这些基本的特性，整个过程就能正常工作，不管按什么顺序放置选项。

#### 14.4.2 使用 getopt 命令

上面的脚本已经有了处理命令行的基本功能，但还无法实现一些常用的高级功能，比如说合并选项，当用户输入`test.sh -ab`，应该既有 -a 的功能也有 -b 的功能。

所以我们要使用`getopt`命令，它能识别命令行参数，从而在脚本中解析它们时更方便。

**1. 命令的格式**



> 阅读至 P300 315