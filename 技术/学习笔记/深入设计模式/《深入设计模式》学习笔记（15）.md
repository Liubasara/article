---
name: 《深入设计模式》学习笔记（15）
title: 《深入设计模式》学习笔记（15）
tags: ["技术","学习笔记","深入设计模式"]
categories: 学习笔记
info: "深入设计模式 第8章 结构型模式 8.7 代理"
time: 2022/3/8
desc: '深入设计模式, 学习笔记, 第8章 结构型模式 8.7 代理'
keywords: ['深入设计模式', '前端', '学习笔记', '第8章 结构型模式', '8.7 代理']
---

# 《深入设计模式》学习笔记（15）

## 第8章 结构型模式

### 8.7 代理

代理是一种能够提供对象的替代品或其占位符的设计模式，代理对象控制着对于原对象的访问，代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。

#### 问题

为什么要控制对于某个对象的访问呢？有一些操作，与业务代码无关，又或是无法直接将这些操作放到第三方封闭库里面，这时候就需要使用代理模式。

#### 解决方案

代理模式建议新建一个与原服务对象接口相同的代理类，然后更新应用以将代理对象传递给所有原始对象客户端，而代理类在接收到客户端的请求以后，将会创建实际的服务对象，并将所有工作委派给它。

![8-20.png](./images/8-20.png)

代理可以将自己伪装成目标对象，可在客户端或被代理对象无感知的情况下处理延迟初始化、缓存查询结果等工作。

这样做的好处是，无需修改类就能在主要业务逻辑前后执行一些工作，由于代理实现的接口与原类相同，因此你可以将其传递给任何一个使用实际服务对象的客户端。

#### 结构

![8-21.png](./images/8-21.png)

1. **服务接口**：该类声明了服务接口，代理必须遵循该接口才能伪装成服务对象。
2. **服务**：该类提供了一些实用的业务逻辑。
3. **代理**：该类包含一个指向服务对象的引用成员变量。代理在完成其额外的任务之后（比如延迟初始化，记录日志，访问控制，缓存等等）会将请求传递给真正的对象。通常情况下，代理会对其代理的服务对象进行整个生命周期的管理。
4. **客户端**：能通过同一接口与服务或代理进行交互，所以客户端可以在一切需要服务对象的代码中使用代理。

#### 伪代码

![8-22.png](./images/8-22.png)

上图的结构演示了在使用第三方腾讯视频的程序库时，使用代理模式为其添加延迟初始化和缓存功能。

程序库提供了视频下载类，但是该类的效率非常低，如果客户端程序多次请求同一个视频，会造成重复下载而不会将首次下载的文件缓存下来使用。

代理模式可以实现原下载器接口的同时，保存所有文件的下载记录，如果程序多次请求同一文件，它将会返回缓存的文件，否则便将所有工作委派给原下载器。

```typescript
/**
 * The Subject interface declares common operations for both RealSubject and the
 * Proxy. As long as the client works with RealSubject using this interface,
 * you'll be able to pass it a proxy instead of a real subject.
 */
interface Subject {
    request(): void;
}

/**
 * The RealSubject contains some core business logic. Usually, RealSubjects are
 * capable of doing some useful work which may also be very slow or sensitive -
 * e.g. correcting input data. A Proxy can solve these issues without any
 * changes to the RealSubject's code.
 */
class RealSubject implements Subject {
    public request(): void {
        console.log('RealSubject: Handling request.');
    }
}

/**
 * The Proxy has an interface identical to the RealSubject.
 */
class Proxy implements Subject {
    private realSubject: RealSubject;

    /**
     * The Proxy maintains a reference to an object of the RealSubject class. It
     * can be either lazy-loaded or passed to the Proxy by the client.
     */
    constructor(realSubject: RealSubject) {
        this.realSubject = realSubject;
    }

    /**
     * The most common applications of the Proxy pattern are lazy loading,
     * caching, controlling the access, logging, etc. A Proxy can perform one of
     * these things and then, depending on the result, pass the execution to the
     * same method in a linked RealSubject object.
     */
    public request(): void {
        if (this.checkAccess()) {
            this.realSubject.request();
            this.logAccess();
        }
    }

    private checkAccess(): boolean {
        // Some real checks should go here.
        console.log('Proxy: Checking access prior to firing a real request.');

        return true;
    }

    private logAccess(): void {
        console.log('Proxy: Logging the time of request.');
    }
}

/**
 * The client code is supposed to work with all objects (both subjects and
 * proxies) via the Subject interface in order to support both real subjects and
 * proxies. In real life, however, clients mostly work with their real subjects
 * directly. In this case, to implement the pattern more easily, you can extend
 * your proxy from the real subject's class.
 */
function clientCode(subject: Subject) {
    // ...

    subject.request();

    // ...
}

console.log('Client: Executing the client code with a real subject:');
const realSubject = new RealSubject();
clientCode(realSubject);

console.log('');

console.log('Client: Executing the same client code with a proxy:');
const proxy = new Proxy(realSubject);
clientCode(proxy);
```

#### 适合应用场景







> 本次阅读至 P226 227  下次阅读应至 240