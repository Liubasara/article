---
name: 《JavaScript异步编程》学习笔记（四）
title: 《JavaScript异步编程》学习笔记（四）
tags: ["技术","学习笔记","JavaScript异步编程"]
categories: 学习笔记
info: "JavaScript异步编程 第6章 异步的脚本加载"
time: 2019/4/18
desc: 'JavaScript异步编程, 学习笔记, 第6章 异步的脚本加载'
keywords: ['前端', 'JavaScript异步编程', '学习笔记', '第6章 异步的脚本加载']
---

# 《JavaScript异步编程》学习笔记（四）

> 引用资料：
>
> - [原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的](https://juejin.im/post/59c60691518825396f4f71a1)

## 第6章 异步的脚本加载

在 html 文件中，我们经常能看到这样的代码：

```html
<script src="allMyClientSideCode.js"></script>
```

> 这有点儿……不怎么样。“这该放在哪儿？”开发人员会奇怪，“靠上
> 点，放到`<head>`标签里？还是靠下点，放到`<body>`标签里？”这两
> 种做法都会让富脚本站点的下场很凄惨。` <head>`标签里的大脚本会
> 滞压所有页面渲染工作，使得用户在脚本加载完毕之前一直处于“白
> 屏死机” 状态。而`<body>`标签末尾的大脚本只会让用户看到毫无生
> 命力的静态页面，原本应该进行客户端渲染的地方却散布着不起作用
> 的控件和空空如也的方框。 

完美解决这个问题需要对脚本**分而治之**：那些调整页面结构，功能的脚本应该立即加载，而那些可以待会再加载的脚本稍后再加载。那具体到落实上，应该怎么做才能既滞压这些脚本，又能保证它们再被调用时的可用性呢？

本章将介绍 HTML5 的 async/defer 属性的作用，以及两个流行的脚本加载库：yepnope 和 Require.js。

关于更多浏览器执行下载解析渲染页面文档中的细节，可以看看[这篇文章](https://juejin.im/post/59c60691518825396f4f71a1)，描述的十分清楚。

### 6.1 局限性与补充说明

在主题之前，读者要注意以下事项：

- 本章的技术不适合用于内联脚本，即那些在页面标记中直接定义的脚本。请勿试图对这种脚本使用 defer / async 属性。
- 使用本章任何技术时请勿使用 document.write。document.write相当于在操控 DOM 时使用 GOTO 语句，这回导致异步加载脚本时的不可预知行为。

> 页面加载优化技术是一个相关专著已汗牛充栋的丰富主题，而脚本加
> 载技术不过是其中的一小部分。但对那些不曾使用过异步加载技术的
> 富脚本站点来说，使用本章的一些技术能唾手可得丰厚的回报。 

### 6.2 `<script>`标签的再认识

现代浏览器中的`<script>`标签分成了两种新类型：经典型和非阻塞型。

#### 6.2.1 阻塞型脚本何去何从

标准版本的`<script>`标签被称为阻塞型标签，当浏览器看到这个标签时，会跳过阻塞点继续读取文档及下载其他资源(脚本和样式表)。**但直到脚本下载完毕并运行之后**，浏览器才会开始加载解析并渲染阻塞点之后的那些资源。

因此，如果网页文档的`<head>`标签里有5个阻塞型的`<script>`标签，则在所有这5个脚本均下载完毕并且运行之前，用户除了页面标题之外看不到任何东西。

即便脚本运行了，它们也只能看到阻塞点之前的那部分文档(**浏览器在遇到`<script>`标签时会触发页面渲染，以确保脚本拿到的是最新的DOM**)。如果想看到`<body>`标签中正在等待加载的页面。就必须给像`document.onreadystatechange`或者`window.onload`这样的事件绑定一个事件处理器。

基于以上的原因，对于普通的`<script>`标签来说，最好的做法就是将其放在页面`<body>`标签的尾部。这样一方面可以让用户更快的看到一面。另一方面脚本也可以主动亲密接触 DOM 而无需等待页面加载事件来触发自己。对多数脚本而言，这次"搬家"都会是巨大的进步。

但并非所有的脚本都是这样的，在这样做之前要先确保几个条件：

- 该脚本没有被页面中的内联 JavaScript 直接调用
- 该脚本支持老式浏览器识别 HTML5 元素
- 该脚本是否会影响已渲染页面的外观。如果会的话，页面就相当于渲染了多次，性能反而可能会有所下降。

上述是哪个问题只要有一个答案是否，那么就都应该把 script 标签放在 head 标签中。

#### 6.2.2 脚本的延迟运行

> 理想情况下，脚本的加载应该与文档的加载同时进行，并且不影响
> DOM 的渲染。这样，一旦文档就绪就可以运行脚本，因为已经按照
>
> `<script>`标签的次序加载了相应脚本。
>
> 如果大家已经读到这里了，那么一定会迫不及待地想写一个自定义
> Ajax 脚本加载器以满足这样的需求！
>
> 不过，大多数浏览器都支持一个更为简单的解决方案。
>
>  ```html
> <script defer src = "deferredScript.js">
>  ```
>
> 添加 defer（延迟）属性相当于对浏览器说：“请马上开始加载这个
> 脚本吧，但是，请等到文档就绪且所有此前具有 defer 属性的脚本
> 都结束运行之后再运行它。” 
>
> 在文档`<head>`标签里放入延迟脚本，既
> 能带来脚本置于`<body>`标签时的全部好处，又能让大文档的加载速
> 度大幅提升！ 

但要注意的是，并非所有浏览器都支持 derfer(现在大部分已经支持了)。如果想要在不支持的浏览器上使用，那就必须再引入一份不在 defer 操作下也能运行的同样功能的脚本，做 polyfill 以防万一。

#### 6.2.3 脚本的完全并行化

使用 async 功能字段可以进一步的将页面中引进的 JavaScript 异步化，使用 async 字段的脚本既不会等之前的脚本运行完成，也不会阻塞页面，它会**尽快加载并且尽快运行这些脚本**。

> 大家可能会问：“如果我对同一个脚本既用defer又用async，会
> 怎么样呢？”答案是，在那些同时支持这两个属性的浏览器中，
> async会覆盖掉defer。由于defer有着更广泛的支持，而且具有
> async的主要优势（允许在下载脚本的同时进行DOM的渲染），因
> 此我们建议尽量使用defer代替async。

关于 script 标签位置所造成的不同差异就讨论到这里，下一节我们来了解如何使用脚本来加载其他的脚本，以便进步一利用异步加载原理。

### 6.3 可编程的脚本加载

本节会介绍如何用脚本加载其他脚本。再介绍两个库：yepnope 和 Require.js。

#### 6.3.1 直接加载脚本

在浏览器 API 层面，有两种合理的方法来抓取并运行服务器脚本。

1. 生成 Ajax 请求并用 eval 函数处理响应
2. 向 DOM 插入`<script>`标签

实际操作中，第二种要比第一种好得多，浏览器会替我们操心生成 HTTP 请求这样的事，再者，使用 `eval` 也会造成许多额外的问题，**慎用**。

我们可以用类似下面的代码来插入 script 标签。

```javascript
var head = document.getElementByTagName('head')[0]
var script = document.createElement('script')
script.src='/js/feture.js'
head.appendChild(script)
```

同时，我们可以给脚本本身添加一些代码以触发事件，HTML5 规范定义了一个可以绑定回调的 onload 属性。

```javascript
script.onload = function () {
    // 调用脚本里定义的函数
}
```

PS：IE8 及更老的版本不支持 onload，仅支持像 onreadystatechange 这样的老旧事件。

#### 6.3.2 yepnope 的条件加载

本节介绍一个用于加载的第三方轻量脚本库，跳过。

#### 6.3.3 Require.js / AMD 智能加载

> Require.js这个强大的工具 包能够自动和 AMD技术一起捋顺哪怕复杂的脚本依赖图。 
>
> 我们稍后再讨论 AMD，现在先来看一个用到 Require.js同名函数的简 单脚本加载示例。 

```javascript
require(['moment'], function (moment) {
    console.log(moment.format('dddd')) // 星期几
})
```

`require`函数接受一个由模块名称构成的数组，然后并行地加载所有这些脚本模块。Require.js 不会保证按照顺序运行目标脚本，只是保证它们运行次序能满足各自的依赖。但前提是这些脚本的定义遵循了 AMD(Asynchronous Module Definition，异步模块定义) 规范。

AMD 规范的宗旨是替浏览器作 CommonJS 标准已经替服务器做过的事。(Node.js模块即基于 CommonJS 标准。)AMD 推行一个由 Require.js 负责提供的一个名叫`define`的全局函数。

该函数有3个参数：

- 模块名称
- 模块依赖性列表
- 在依赖性模块加载结束后触发的回调

例如，下面的 define 语句可以作为依赖 jQuery 之应用模块的有效 AMD 定义。

```javascript
define('myApplication', ['jquery'], function ($) {
    $('<body>').append('<p>hello world!!</p>')
})
```

注意这里传递给回调的是 jQuery 的对象 $ 。实际上， define 接受的这个回调参数一直对应着依赖性列表中的各个模块依赖项。

那么 define 怎样知道捕获 jQuery 呢？(就是说 jQuery 是怎么 export 的呢？)

答案是 jQuery 自己的 AMD 定义 通过其 define 回调返回了 jQuery 对象，借此声明了其导出的对象。

```javascript
define("jquery", [], function () { return jQuery })
```

> 如果应用的每个脚本都添加了 AMD定义，则意味着我们只要调用 require 就能保证其回调不 被调用，除非既满足了应用对脚本的直接依赖性，又满足了脚本的依 赖性和脚本所依赖的那些脚本的依赖性，并且所有脚本均按大的并行性进行加载，而运行次序也和依赖图一致

> 听起来很棒，是吧？但也有一点美中不足：虽然 AMD 已经在 JavaScript社区产生了一些影响，但仍然有大量的观望者。譬如，Jeremy Ashkenas 就拒绝为其广受欢迎的 Underscore.js/Backbone.js 库添加必 要的 AMD规范，他还在等待着一个 ECMAScript模块标准。因此， 我们不能指望第三方模块都带有自己的 AMD定义。选择 AMD会让应用更具一致性，但这也会滋生呆板木讷的代码。 

而事实上时至今日，别说 AMD/CMD了，就连 ES6 都已经支持动态引入了。

