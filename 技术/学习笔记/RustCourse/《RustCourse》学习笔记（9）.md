---
name: 《RustCourse》学习笔记（9）
title: 《RustCourse》学习笔记（9）
tags: ["技术","学习笔记","RustCourse"]
categories: 学习笔记
info: "第2章 Rust基本概念 2.9 集合类型 2.9.1 动态数组 Vector"
time: 2024/3/19
desc: 'RustCourse, 学习笔记'
keywords: ['RustCourse', '学习笔记', 'rust']
---

# 《RustCourse》学习笔记（9）

## 第2章 Rust基本概念

### 2.9 集合类型

> https://course.rs/basic/collections/intro.html

集合中的类型是分配在堆上的，因此都可以进行动态的增加和减少，比如下面的这些类型：

- `Vector`类型，创建一个动态数组
- `HashMap`类型，创建一个动态的`KV`对
- `String`类型，创建一个可动态修改的字符串

### 2.9.1 动态数组 Vector

##### 2.9.1.1 创建方式

1. Vec::new

   ```rust
   let v: Vec<i32> = Vec::new();
   ```

   或者：

   ```rust
   let mut v = Vec::new();
   // 只要有赋值，就能自动推导类型
   v.push(1);
   ```

2. vec![]

   ```rust
   // 可自动推导类型
   let v = vec![1, 2, 3];
   ```

##### 2.9.1.2 更新 Vector

向数组尾部添加元素，可以使用 `push` 方法：

```rust
let mut v = Vec::new();
v.push(1);
```

与其它类型一样，必须将 `v` 声明为 `mut` 后，才能进行修改。

##### 2.9.1.3 Vecotr 生命周期

跟结构体一样，`Vector` 类型在超出作用域范围后，会被自动删除：

```rust
{
    let v = vec![1, 2, 3];

    // ...
} // <- v超出作用域并在此处被删除
```

当 `Vector` 被删除后，它内部存储的所有内容也会随之被删除。目前来看，这种解决方案简单直白，但是当 `Vector` 中的元素被引用后，事情可能会没那么简单。

##### 2.9.1.4 在 Vector 中读取元素

- 通过下标索引访问
- 使用 get 方法

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("第三个元素是 {}", third);

match v.get(2) {
    Some(third) => println!("第三个元素是 {third}"),
    None => println!("去你的第三个元素，根本没有！"),
}
```

> 下标索引与 `.get` 的区别
>
> 这两种方式都能成功的读取到指定的数组元素，既然如此为什么会存在两种方法？何况 `.get` 还会增加使用复杂度，这就涉及到数组越界的问题了，让我们通过示例说明：
>
> ```rust
> let v = vec![1, 2, 3, 4, 5];
> 
> let does_not_exist = &v[100];
> let does_not_exist = v.get(100);
> ```
>
> 运行以上代码，`&v[100]` 的访问方式会导致程序无情报错退出，因为发生了数组越界访问。 但是 `v.get` 就不会，它在内部做了处理，有值的时候返回 `Some(T)`，无值的时候返回 `None`，因此 `v.get` 的使用方式非常安全。
>
> 既然如此，为何不统一使用 `v.get` 的形式？因为实在是有些啰嗦，Rust 语言的设计者和使用者在审美这方面还是相当统一的：简洁即正义，何况性能上也会有轻微的损耗。
>
> 既然有两个选择，肯定就有如何选择的问题，答案很简单，当你确保索引不会越界的时候，就用索引访问，否则用 `.get`。例如，访问第几个数组元素并不取决于我们，而是取决于用户的输入时，用 `.get` 会非常适合，天知道那些可爱的用户会输入一个什么样的数字进来！

##### 2.9.1.5 同时借用多个数组元素



