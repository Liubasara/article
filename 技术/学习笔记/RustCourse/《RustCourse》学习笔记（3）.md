---
name: 《RustCourse》学习笔记（3）
title: 《RustCourse》学习笔记（3）
tags: ["技术","学习笔记","RustCourse"]
categories: 学习笔记
info: "第2章 Rust基本概念 2.2.2 字符、布尔、单元类型 2.2.3 语句和表达式 2.2.4 函数 2.3 所有权和借用"
time: 2024/2/1
desc: 'RustCourse, 学习笔记'
keywords: ['RustCourse', '学习笔记', 'rust']
---

# 《RustCourse》学习笔记（2）

## 第2章 Rust基本概念

### 2.2 基本类型

> https://course.rs/basic/ownership/ownership.html

#### 2.2.2 字符、布尔、单元类型

**字符**

字符类型（char）类型可以理解为英文中的字幕，中文中的汉字。Rust 的字符不仅仅是`ASCII`，所有的`Unicode`值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 等等，都是合法的字符类型。字符类型和`Unicode`都是 4 个字节编码。

和一些语言不同，Rust 的字符只能用`''`来表示，`""`是留给字符串的。

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let g = '国';
    let heart_eyed_cat = '😻';
}
```

**布尔（bool）**

Rust 中的布尔类型有两个可能的值：true 和 false。布尔值占用内存的大小为 1 个字节。

**单元类型**

单元类型就是`()`，唯一的值也是`()`，比如`fn main()`函数的返回值类型就是单元类型。返回单元类型的函数与无返回值函数并不是一个概念，Rust 对于没有返回值的函数有单独的定义：`发散函数(diverge function)`。

常见的`println!()`的返回值也是单元类型，再比如可以用`()`作为 map 的值，这表示我们不关注具体的值，只关心它对应的`key`。这个值也不会占用任何内存。

#### 2.2.3 语句和表达式

> Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如：
>
> ```rust
> fn add_with_extra(x: i32, y: i32) -> i32 {
>     let x = x + 1; // 语句
>     let y = y + 5; // 语句
>     x + y // 表达式
> }
> ```

在 Rust 中，`语句`是不会有返回值的，因此在 rust 中，不能这么写：`let b = (let a = 8);`

在 Rust 中，`表达式`会进行求值，并返回一个值。换句话说，只要能返回值的操作，它就是表达式。如果表达式不反悔任何值，则会隐式地返回一个`()`。

```rust
fn main() {
    assert_eq!(ret_unit_type(), ())
}

fn ret_unit_type() {
    let x = 1;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let y = if x % 2 == 1 {
        "odd"
    } else {
        "even"
    };
    // 或者写成一行
    let z = if x % 2 == 1 { "odd" } else { "even" };
}
```

#### 2.2.4 函数

```rust
fn add(i: i32, j: i32) -> i32 {
   i + j
 }
```

- 函数名和变量名使用[蛇形命名法(snake case)](https://course.rs/practice/naming.html)，例如 `fn add_two() -> {}`
- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
- 每个函数参数都需要标注类型

![2-1.png](./images/2-1.png)

**Rust 中的特殊返回类型**

**无返回值`()`**

单元类型是一个零长度的元组，用于表达一个函数没有返回值。既可以显式返回，也可以默认的隐式定义。

> 例如下面的 `report` 函数会隐式返回一个 `()`：
>
> ```rust
> use std::fmt::Debug;
> 
> fn report<T: Debug>(item: T) {
>   println!("{:?}", item);
> 
> }
> ```
>
> 与上面的函数返回值相同，但是下面的函数显式的返回了 `()`：
>
> ```rust
> fn clear(text: &mut String) -> () {
>   *text = String::from("");
> }
> ```

**永不返回的发散函数`!`**

> 当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：
>
> ```rust
> fn dead_end() -> ! {
>   panic!("你已经到了穷途末路，崩溃吧！");
> }
> ```
>
> 下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：
>
> ```rust
> fn forever() -> ! {
>   loop {
>     //...
>   };
> }
> ```

### 2.3 所有权和借用

在以往，内存安全几乎都是通过 GC（Garbage Collect：自动垃圾回收）的方式实现，但是 GC 会引来性能、内存占用以及 Stop the world 的问题，在高性能场景和系统编程上是不可接受的。因此 Rust 采用了与众不同的方式：**所有权系统**。

#### 2.3.1 所有权

在计算机语言演变的过程中，如何从内存中申请空间来存放程序的运行内容，如何释放空间，一直是重点难题，在不断演变的过程中，出现了三种流派：

- 垃圾回收机制（GC）：在程序运行时不断寻找不再使用的内存，典型代表：GO、JAVA
- 手动管理内存的分配和释放：在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- 通过所有权来管理内存：编译器在编译时会根据一系列规则进行检查

Rust 选择了第三种路，这种检查只发生在编译器，因此在程序运行期间，不会有任何性能上的损失。

在本章，我们将通过`字符串`来引导讲解所有权的相关知识。

**一段不安全的代码**

下面是一段 C 语言的代码：

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
} // 变量a和c的作用域结束
```

上面的代码中存在两处问题：

1. 局部变量`a`：变量`a`所申请的栈上内存（个人理解：也就是数字`100`所存放的地方），在函数执行完以后都会被系统回收，但是由于函数结束以后将变量的`a`的地址返回了，所以造成了`悬空指针(Dangling Pointer)`的问题（**个人理解：有一个空指针，指向了一片不存在内容的地址**）。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现很多错误。

2. 局部变量`c`：第二个问题不算是错误，但也是经常存在的问题。`c`的指针所指向的值是常量字符串，存储于常量区，而 "xyz" 这个字符串所代表的内存区域需要当整个程序结束后，系统才会回收。如果你想要动态进行回收，则只能用别的方法，比如`malloc`和`free`方法：

   ```c
   // C
   char* str = malloc(6); // 分配足够的内存来存储 "hello" 和末尾的 '\0'
   strcpy(str, "hello"); // 复制字符串到新分配的内存
   // ... 使用 str ...
   free(str); // 当你完成了 str 的使用，释放内存
   ```

**栈（stack）和堆（Heap）**

> 栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能。
>
> 栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。

栈按照顺序存储值并以相反顺序取出值，栈中所有的数据都必须占用已知且固定大小的内存空间。假设数据大小是未知的，那么在取出数据时，将无法取到想要的数据。

对于大小未知或者可能变化的数据，需要存放在堆上。向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该未知地址的**指针**。该过程成为**在堆上分配内存**，简称为“分配”（allocating）。**该指针会被推入到栈中**（因为指针的大小是确定的），在后续的使用过程中，将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。

> 由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。

**性能区别**

在栈上分配内存比在堆上分配内存更快。

##### 所有权与堆栈*

当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）（个人理解：VB？）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

> 因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。
>
> 对于其他很多编程语言，你确实无需理解堆栈的原理，但是**在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助**。

##### 所有权原则

所有权原则有以下规则：

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值得拥有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者（变量）离开作用域范围时，这个值将被丢弃（drop）

##### 变量作用域

就作用域来说，Rust 语言跟其他编程语言没有区别。作用域是一个变量在程序中有效的范围，假如有这样一个变量：

```rust
let s = "hello";
```

变量`s`绑定了一个字符串，该变量从声明的点开始直到当前作用域的结束都是有效的。

```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s不再有效
```

##### 简单介绍 String 类型

- 字符串字面值（个人理解：即类似像`let s = "hello"`这样的赋值就就是字面值赋值）是不可变的，因为被硬编码到程序代码中。

- 并非所有字符串的值都能在编写代码时得知，例如需要由用户动态输入然后存储到内存中的时候，此时需要使用动态字符串类型 String。如：

  ```rust
  let s = String::from("hello");
  ```

  此时的字符串存储在堆上，因此是动态的，可以进行修改，如：

  ```rust
  let mut s = String::from("hello");
  
  s.push_str(", world!"); // push_str() 在字符串后追加字面值
  
  println!("{}", s); // 将打印 `hello, world!`
  ```

  了解 String 之后，一起来看看所有权的交互。

##### 变量绑定背后的数据交互

（个人理解：Rust 中的变量都有两重含义，第一重是变量所代表的指针，第二重是该指针所指向的内存地址。Rust 在变量绑定时，如果内存地址中存储的是某些特定的基础类型的值，就会允许这个值进行拷贝并复制到对应的内存地址中，也就是这两个变量都能在后续使用。对于复杂的值，一旦进行了绑定，只会对其栈上的指针的值进行拷贝，同时会自动销毁掉前一个变量对于旧指针的访问许可。当最终持有所有权的变量离开作用域，也就代表着相应内存地址上面的内存可被释放。）

例如下面这段代码，在 Rust 中就会存在编译错误：

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
}
```

![2-2.png](./images/2-2.png)

```txt
 Compiling hello-world v0.1.0 (/app/data/hello-world)
warning: unused variable: `s2`
 --> src/main.rs:3:9
  |
3 |     let s2 = s1;
  |         ^^ help: if this is intentional, prefix it with an underscore: `_s2`
  |
  = note: `#[warn(unused_variables)]` on by default

error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
warning: `hello-world` (bin "hello-world") generated 1 warning
error: could not compile `hello-world` due to previous error; 1 warning emitted
```

> 如果你在其他语言中听说过术语 浅拷贝(shallow copy) 和 深拷贝(deep copy)，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 s1 无效了，因此这个操作被称为 移动(move)，而不是浅拷贝。

Rust 永远不会自动深拷贝任何数据，因为这会极大程度的拖慢程序的运行性能。上述的复制都是指浅拷贝，**由于上述的浅拷贝只发生在栈上，因此性能很好**。

对于深拷贝，对于一些对象，rust 支持调用 `clone` 方法来实现深拷贝，如上面报错的代码，可以改成：

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

这段代码能够正常运行，说明`s2`变量并没有夺取`s1`的所有权，而是完整的复制了它的数据。

那么在赋值的时候，哪些变量会自动执行浅拷贝赋值，而不是通过夺取所有权的方法赋值呢？

> Rust 有一个叫做 `Copy` 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。
>
> 那么什么类型是可 `Copy` 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则： **任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**。如下是一些 `Copy` 的类型：
>
> - 所有整数类型，比如 `u32`
>
> - 布尔类型，`bool`，它的值是 `true` 和 `false`
>
> - 所有浮点数类型，比如 `f64`
>
> - 字符类型，`char`
>
> - 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是
>
> - 不可变引用 `&T` ，例如下面的例子，**但是注意: 可变引用 `&mut T` 是不可以 Copy的**：
>
>   ```rust
>   fn main() {
>       let x: &str = "hello, world";
>       let y = x;
>       println!("{},{}",x,y);
>   }
>   ```
>
>   上面的`let y = x` 中，仅仅是对该引用进行了拷贝，存储了在二进制中的字符串的引用指针，而并没有持有所有权。（个人理解，这里的"hello, world"所代表的是一段特殊的不可变的内存地址上面的值，一直到程序结束之前，这块内存地址都不会被释放，所以根本不需要所有权这个概念存在。也因此引用这个值的指针地址也就变成了一个常量，所以这个变量的值可以被 COPY（详细解释可见[这里](https://github.com/sunface/rust-course/discussions/690#discussioncomment-3182086)））。

##### 函数传值与返回

将值传递给函数，一样会发生`移动`或者`复制`。

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效
    println!("在move进函数后继续使用s, 期望报错: {}",s); // 报错
  
    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

同样的，函数的返回值也有所有权。

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from("hello"); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
```

所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： **总是把一个值传来传去来使用它**。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。









